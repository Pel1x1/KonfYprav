# Установка
1. Установка программы и переход в директорию
   ```bash
   git clone <URL репозитория>
   cd <директория проекта>
   ```
2. Создайте и активируйте виртуальное окружение:
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # Для Linux/Mac
   venv\Scripts\activate     # Для Windows
   ```
3. Установите необходимые зависимости :
   ```bash
   Зависимости не требуются
   ```

# Файловая структура

```
Assembler (assembler.py) — Ассемблирует инструкции из файла ASM в бинарный файл
Interpreter (interpreter.py) — Интерпретирует бинарный файл и выводит результат в CSV.
task.asm              # Исходный файл с программой на ассемблере
output.bin            # Бинарный файл с ассемблированными инструкциями
log.txt               # Лог-файл с ассемблированными инструкциями
result.csv            # CSV-файл с результатами выполнения программы
unittests.py          # файл с Unit тестированием программы
```

# Запуск 
1. Запуск ассемблера (assembler.py)
   ``` bash
   py assembler.py task.asm output.bin log.txt
   py <скрипт> <файл с заданием> <выходной файл bin> <лог-файл>
   ```
   Для работы в task.asm должно содержаться задание

   ```bash
   Вариант №11. Выполнить поэлементно операцию побитовое исключающее "или" над вектором длины 7 и числом 134. Результат записать в новый вектор.

   xor [0,1,2,3,4,5,6] 134
   <действие> [вектор] <число>
   В условии не сказано какие значения содержит исходный вектор поэтому я сделал просто от 0 до 6
   ```
2. Запуск интерпретатора (interpreter.py)
   ``` bash
   py interpreter.py output.bin result.csv
   py <скрипт> <bin файл с инструкцией> <файл с результатом>
   ```

# Результат
1. xor [0,1,2,3,4,5,6] 134

```
Сначала переведем 134 в двоичную систему: 134 = 10000110
Теперь выполним XOR каждого элемента массива с 134:
0 ^ 134 = 134 (10000110)
1 ^ 134 = 135 (10000111)
2 ^ 134 = 132 (10000100)
3 ^ 134 = 133 (10000101)
4 ^ 134 = 130 (10000010)
5 ^ 134 = 131 (10000011)
6 ^ 134 = 128 (10000000)

134, 135, 132, 133, 130, 131, 128
```

2. xor [9,8,7,1,2,3,6] 134

```
Число 134 в двоичной системе: 134 = 10000110
Выполняем XOR каждого элемента массива с 134:
9 ^ 134 = 143 (10001111)
8 ^ 134 = 142 (10001110)
7 ^ 134 = 141 (10001101)
1 ^ 134 = 135 (10000111)
2 ^ 134 = 132 (10000100)
3 ^ 134 = 133 (10000101)
6 ^ 134 = 128 (10000000)

143, 142, 141, 135, 132, 133, 128
```

3. xor [0,1,2,3,4,5,6] 56

```
Число 56 в двоичной системе: 56 = 00111000
Выполняем XOR каждого элемента массива с 56:
0 ^ 56 = 56 (00111000)
1 ^ 56 = 57 (00111001)
2 ^ 56 = 58 (00111010)
3 ^ 56 = 59 (00111011)
4 ^ 56 = 60 (00111100)
5 ^ 56 = 61 (00111101)
6 ^ 56 = 62 (00111110)

56, 57, 58, 59, 60, 61, 62
```
4. or [0,1,2,3,4,5,6] 134

```
Число 134 в двоичной системе: 134 = 10000110
Выполняем OR каждого элемента массива с 134:
0 | 134 = 134 (10000110)
1 | 134 = 135 (10000111)
2 | 134 = 134 (10000110)
3 | 134 = 135 (10000111)
4 | 134 = 134 (10000110)
5 | 134 = 135 (10000111)
6 | 134 = 134 (10000110)

134, 135, 134, 135, 134, 135, 134
```

Результат выполнения программы совпадает с решением в ручную во всех случаях




